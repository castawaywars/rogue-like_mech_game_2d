<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Rogue-like mech game - game screen</title>
	<link rel="stylesheet" href="./style.css">
</head>

<body>
	<h1>Game screen</h1>
	<a href="./index.html">index</a>

	<div style="display: flex; flex-direction: row;">

		<table>
			<tr>
				<td>Kills<br><span id="m_score">0</span></td>
				<td onclick="move_up('m')">W</td>
				<td>HP<br><span id="m_health">5</span></td>
			</tr>
			<tr>
				<td onclick="move_left('m')">A</td>
				<td class="m" onclick="shoot('m')">Shoot:<br>Q</td>
				<td onclick="move_right('m')">D</td>
			</tr>
			<tr>
				<td onclick="reload_gun('m')">Gun&nbsp;ammo<br><span id="m_gun_ammo">0</span><br>reload E</td>
				<td onclick="move_down('m')">S</td>
				<td>Flame&nbsp;ammo<br><span id="m_flame_ammo">0</span></td>
			</tr>
		</table>

		<p>You can control the mechs with wasd, q for shooting, e for reloading for player 1 and the arrow keys, - for
			shooting, . for reloading for player two, or use the clickable tiles above and below the map, especially
			helpful on touch screens.<br>
			The walkable places are green, the mechs are <span class="m">blue (player 1)</span> and <span
				class="n">yellow (player 2)</span>, <span class="e">enemies are red</span>, enemy spawners are black,
			<span class="w">simple obstacles are grey</span>, health packs are white, and <span class="f">flamethrower
				ammo (not functional yet) is orange.</span><br>
			You can see what direction the mech is facing by the black bar. Shooting shoots forward in whatever
			direction you are currently facing. Enemies die in one shot. If an enemy walks into you, he will damage you.
			If your health drops to 0, you die and the enemy that killed you is promoted into a new spawner on the spot
			you died on.<br>
			If your gun is out of ammo, you can't shoot, you will have to reload. Don't spam the reload button though,
			as reloading takes a second, and you can't shoot during the reloading.
		</p>

	</div>

	<table id="the_table"></table>

	<table>
		<tr>
			<td>Kills<br><span id="n_score">0</span></td>
			<td onclick="move_up('n')">&uarr;</td>
			<td>HP<br><span id="n_health">5</span></td>
		</tr>
		<tr>
			<td onclick="move_left('n')">&larr;</td>
			<td class="n" onclick="shoot('n')">Shoot:<br>-</td>
			<td onclick="move_right('n')">&rarr;</td>
		</tr>
		<tr>
			<td onclick="reload_gun('n')">Gun&nbsp;ammo<br><span id="n_gun_ammo">0</span><br>reload :</td>
			<td onclick="move_down('n')">&darr;</td>
			<td>Flame&nbsp;ammo<br><span id="n_flame_ammo">0</span><br></td>
		</tr>
	</table>

	<!-- get all the maps, imported as JS scripts because that works reliably, and the maps can be made to have that format -->
	<script src="./maps/deadly_horde.js"></script>
	<script src="./maps/fortress.js"></script>
	<script src="./maps/test_map.js"></script>
	<script src="./maps/test_map2.js"></script>

	<!-- import the other scripts -->
	<script src="./scripts/player_triggered_functions.js"></script>
	<script src="./scripts/time_triggered_functions.js"></script>

	<!-- Scripts that are not put into other files -->
	<script>

		var the_table = document.getElementById("the_table");
		var move_delay = 2;
		var spawn_delay = 5;
		var time_since_move = 0;
		var time_since_spawn = 0;

		// ---------- Setup functions ----------

		//function executed on loading the page to set up everything
		function onload() {
			let url = window.location.href;
			let params_string = url.split("?")[1];
			let params_array = params_string.split("&");

			let param_pieces = [];
			for (let param of params_array) {
				//here I can look at each get parameter and set up the game accordingly
				param_pieces = param.split("=");

				if (param_pieces[0] == "map") {
					//get the correct file and draw the map
					switch (param_pieces[1]) {
						case "fortress":
							build_map(fortress);
							break;
						case "deadly_horde":
							build_map(deadly_horde);
							break;
						case "test_map":
							build_map(test_map);
							break;
						case "test_map2":
							build_map(test_map2);
							break;
						default:
							alert("Could not find requested map");
							break;
					}
				} else if (param_pieces[0] == "two_player") {
					//remove player 2 if it's single-player
					if (param_pieces[1] == "no") {
						let n = document.getElementById("n");
						n.removeAttribute("id");
						n.classList.remove("n");
						n.classList.add("0");
					}
				} else if (param_pieces[0] == "move_delay") {
					move_delay = param_pieces[1];
				} else if (param_pieces[0] == "spawn_delay") {
					spawn_delay = param_pieces[1];
				}
			}

			register_event_listeners();

			time_loop();
		}

		//build the map at the start of the game
		function build_map(map_data) {
			let row;
			let cell;
			let rowindex = 0;
			let colindex = 0;

			for (let row_data of map_data) {
				row = document.createElement("tr");
				row.setAttribute("row", rowindex);
				colindex = 0;
				for (let col_data of row_data) {
					cell = document.createElement("td");
					cell.classList.add(col_data);
					cell.setAttribute("row", rowindex);
					cell.setAttribute("column", colindex);
					if (col_data == "m" || col_data == "n") {
						cell.setAttribute("id", col_data);
					}
					colindex++;
					row.appendChild(cell);
				}
				rowindex++;
				table_target().appendChild(row);
			}
		}

		//registers the event listeners for key presses to control the mech
		function register_event_listeners() {
			addEventListener("keydown", (e) => {
				switch (e.code) {
					case "KeyW":
						move_up("m");
						break;
					case "KeyA":
						move_left("m");
						break;
					case "KeyS":
						move_down("m");
						break;
					case "KeyD":
						move_right("m");
						break;
					case "KeyQ":
						shoot("m");
						break;
					case "ArrowUp":
						move_up("n");
						break;
					case "ArrowLeft":
						move_left("n");
						break;
					case "ArrowDown":
						move_down("n");
						break;
					case "ArrowRight":
						move_right("n");
						break;
					case "Slash"://that's actually "-" on my keyboard
						shoot("n");
						break;
					case "KeyE":
						reload_gun("m");
						break;
					case "Period":
						reload_gun("n");
						break;
				}
			});
		}

		//time loop that calls itself to advance the NPCs
		function time_loop() {
			time_since_move++;
			time_since_spawn++;
			if (time_since_move >= move_delay) {
				//move all enemies
				let enemies = document.getElementsByClassName("e");
				for (let enemy of enemies) {
					random_enemy_move(enemy);
				}
				time_since_move = 0;
			}

			if (time_since_spawn >= spawn_delay) {
				spawn_enemy();
				time_since_spawn = 0;
			}

			setTimeout(time_loop, 1000);
		}

		// ---------- Util functions ----------

		/**
		 * returns the parent element of the table rows, either the table, or the auto-generated tbody element
		 * I've had problems with that browser auto-generated element before, I know I have to watch for that.
		 */
		function table_target() {
			if (the_table.children.length > 0 && the_table.children[0].tagName == "TBODY") {
				return the_table.children[0];
			} else {
				return the_table;
			}
		}

		//removes all classes from the class list of a tile and adds the 0 class, making it an empty space
		function tile_set_classes_to_zero(tile) {
			tile.classList = "";
			tile.classList.add(0);
		}

		/**
		 * Utility function to check if a tile is on the map
		 * @param {number} target_row 
		 * @param {number} target_col 
		 * @returns true if location in bounds, false if out of bounds
		 */
		function in_bounds(target_row, target_column) {
			if (target_row < 0 || target_column < 0) {
				return false; //index less than 0, clearly out of bounds
			}
			let the_table = table_target();
			if (the_table.children.length <= target_row || the_table.children[0].children.length <= target_column) {
				return false; //also out of bounds
			}
			return true;
		}

		onload();

	</script>

</body>

</html>