<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>Rogue-like mech game - game screen</title>
	<link rel="stylesheet" href="./style.css">
</head>

<body>
	<h1>Game screen</h1>
	<a href="./index.html">index</a>

	<table id="the_table"></table>

	<!-- get all the maps, imported as JS scripts because that works reliably, and the maps can be made to have that format -->
	<script src="./maps/test_map.js"></script>
	<script src="./maps/test_map2.js"></script>

	<!-- import the other scripts -->
	<script src="./scripts/player_triggered_functions.js"></script>
	<script src="./scripts/time_triggered_functions.js"></script>

	<!-- Scripts that are not put into other files -->
	<script>

		var the_table = document.getElementById("the_table");

		// ---------- Setup functions ----------

		//function executed on loading the page to set up everything
		function onload() {
			let url = window.location.href;
			let params_string = url.split("?")[1];
			let params_array = params_string.split("&");

			let param_pieces = [];
			for (let param of params_array) {
				//here I can look at each get parameter and set up the game accordingly
				param_pieces = param.split("=");

				if (param_pieces[0] == "map") {
					//get the correct file and draw the map
					switch (param_pieces[1]) {
						case "test_map":
							build_map(test_map);
							break;
						case "test_map2":
							build_map(test_map2);
							break;
						default:
							alert("Could not find requested map");
							break;
					}
				} else if (param_pieces[0] == "two_player") {
					//remove player 2 if it's single-player
					if (param_pieces[1] == "no") {
						let n = document.getElementById("n");
						n.removeAttribute("id");
						n.classList.remove("n");
						n.classList.add("0");
					}
				}
			}

			register_event_listeners();

			time_loop();
		}

		//build the map at the start of the game
		function build_map(map_data) {
			let row;
			let cell;
			let rowindex = 0;
			let colindex = 0;

			for (let row_data of map_data) {
				row = document.createElement("tr");
				row.setAttribute("row", rowindex);
				colindex = 0;
				for (let col_data of row_data) {
					cell = document.createElement("td");
					cell.classList.add(col_data);
					cell.setAttribute("row", rowindex);
					cell.setAttribute("column", colindex);
					if (col_data == "m" || col_data == "n") {
						cell.setAttribute("id", col_data);
					}
					colindex++;
					row.appendChild(cell);
				}
				rowindex++;
				table_target().appendChild(row);
			}
		}

		//registers the event listeners for key presses to control the mech //TODO: handlers for shooting missing
		function register_event_listeners() {
			addEventListener("keydown", (e) => {
				switch (e.code) {
					case "KeyW":
						move_up("m");
						break;
					case "KeyA":
						move_left("m");
						break;
					case "KeyS":
						move_down("m");
						break;
					case "KeyD":
						move_right("m");
						break;
					case "ArrowUp":
						move_up("n");
						break;
					case "ArrowLeft":
						move_left("n");
						break;
					case "ArrowDown":
						move_down("n");
						break;
					case "ArrowRight":
						move_right("n");
						break;
					case "Space":
						spawn_enemy();//TODO: this is only for debug, remove later
						break;
				}
			});
		}

		//TODO: time loop that calls itself to advance the NPCs
		function time_loop() {
			//TODO: call various time-triggered functions
		}

		// ---------- Util functions ----------

		/**
		 * returns the parent element of the table rows, either the table, or the auto-generated tbody element
		 * I've had problems with that browser auto-generated element before, I know I have to watch for that.
		 */
		function table_target() {
			if (the_table.children.length > 0 && the_table.children[0].tagName == "TBODY") {
				return the_table.children[0];
			} else {
				return the_table;
			}
		}

		//removes all classes from the class list of a tile and adds the 0 class, making it an empty space
		function tile_set_classes_to_zero(tile) {
			tile.classList = "";
			tile.classList.add(0);
		}

		/**
		 * Utility function to check if a tile is on the map
		 * @param {number} target_row 
		 * @param {number} target_col 
		 * @returns true if location in bounds, false if out of bounds
		 */
		function in_bounds(target_row, target_column) {
			if (target_row < 0 || target_col < 0) {
				return false; //index less than 0, clearly out of bounds
			}
			let the_table = table_target();
			if (the_table.children.length <= target_row || the_table.children[0].children.length <= target_col) {
				return false; //also out of bounds
			}
			return true;
		}

		onload();

	</script>

</body>

</html>